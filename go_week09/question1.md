总结几种 socket 粘包的解包方式: fix length/delimiter based/length field based frame decoder。尝试举例其应用

Socket
封装了TCP和UDP传输通讯协议，
Tcp Transmission Control Protocol 通讯协议
粘包
message1 : ABC message2 : DEF
正常接受 是 收到 ABC DEF
粘包 接受 ABCDEF
半包 消息1：AB 消息2 CDEF or
消息1 ABCD 消息2 EF
why?
TCP协议为了高效传输数据付出的代价
对TCP来说 它处理的底层的数据流，本身没有合适开始和结束的边界
发送数据果果：应用程序发送消息包，消息包以数据流的形式放入缓存区，等缓冲数区的数据流到达一定阈值，在发送到网络上
接受数据过程： 接受到网络过来的数据流，放入缓冲区，缓冲区的数据流到达一定阈值后，通知应用程序进行读取数据。
在数据发送和接受过程，都是对数据流进行操作
1 在发送数据ing
应用程序发送的数据长度超过缓冲区空间，这就发生了数据流拆分，同一个数据包就会通过多次发送完成，也就会出现半包的情况
2 在接受数据ing
应用程序没有继续读取缓冲区的数据流，导致缓冲区放了多个数据包数据，再进行读取，也就会出现粘包

socket 粘包的解包方式
1 发送，每次发送固定长度额数据，并且不超过缓冲区，接收方每次固定长度区接收数据
2 发送，在数据包添加特殊的分割符，用来标记数据包边界
3 发送，在消息数据包头header添加包长度信息